# Конфигурация переменных окружения

## Рекомендация: Один общий .env файл

**Используйте один файл `.env` в корне проекта** для всех сервисов. Это проще в управлении и соответствует best practices для Docker Compose.

### Почему один файл?

✅ **Преимущества:**
- Все переменные в одном месте - легко найти и изменить
- Нет дублирования общих переменных (например, `DATABASE_URL`)
- Проще версионировать и синхронизировать между окружениями
- Docker Compose автоматически загружает только нужные переменные для каждого сервиса

❌ **Недостатки раздельных файлов:**
- Дублирование общих переменных
- Сложнее поддерживать синхронизацию
- Больше файлов для управления

### Структура .env файла

Файл `.env` организован по секциям для удобства:

```bash
# ============================================
# Bot (newsagent)
# ============================================
TELEGRAM_BOT_TOKEN=your_token
TELEGRAM_CHAT_ID=your_chat_id
METRICS_PORT=8000

# ============================================
# Parser
# ============================================
PARSER_INTERVAL=300

# ============================================
# Database (общее)
# ============================================
DATABASE_URL=postgresql://...

# ============================================
# Grafana Alloy
# ============================================
GCLOUD_HOSTED_METRICS_URL=...
GCLOUD_HOSTED_METRICS_ID=...
GCLOUD_RW_API_KEY=...
```

### Как это работает

Docker Compose автоматически:
1. Загружает все переменные из `.env` файла
2. Передает в каждый контейнер только те переменные, которые указаны в секции `environment:` или используются в `env_file:`
3. Каждый сервис видит только свои переменные + общие

### Пример использования

```yaml
# docker-compose.yml
services:
  newsagent:
    environment:
      - TELEGRAM_BOT_TOKEN=${TELEGRAM_BOT_TOKEN}  # Только эта переменная попадет в контейнер
    env_file:
      - ../.env  # Загружает все переменные, но используются только указанные выше

  parser:
    environment:
      - DATABASE_URL=${DATABASE_URL}  # Использует общую переменную
      - PARSER_INTERVAL=${PARSER_INTERVAL}  # Специфичная для парсера
    env_file:
      - ../.env
```

### Альтернатива: Раздельные файлы (если нужно)

Если по каким-то причинам нужна изоляция секретов, можно использовать раздельные файлы:

```yaml
services:
  newsagent:
    env_file:
      - ../.env.bot
  parser:
    env_file:
      - ../.env.parser
  grafana-alloy:
    env_file:
      - ../.env.alloy
```

Но это рекомендуется только для:
- Разных уровней безопасности секретов
- Разных команд, управляющих разными сервисами
- Специфичных требований compliance

### Безопасность

⚠️ **Важно:**
- Файл `.env` **НЕ должен** попадать в Git (уже в `.gitignore`)
- Используйте `.env.example` как шаблон без реальных значений
- В продакшене используйте секреты из менеджера секретов (например, Docker Secrets, Kubernetes Secrets)

